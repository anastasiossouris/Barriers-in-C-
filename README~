In this document i mainly describe the results of the various benchmarks.

Note: i have removed any atomic backoff instance since i do not oversubscribe the machine.

Use objdump -S --disassemble intel_i7_benchmark_suite > dump to read assembly

|-----------------------------------------------|
|Results for Centralized Sense Reversing Barrier|
|-----------------------------------------------|
The instance of the barrier is cache-aligned. Also, the counter and sense instances are cache-aligned to avoid false-sharing. However, they are placed in adjacent cache-lines
and thus the hardware prefetcher could affect the performance.
Thread pinning is performed in the following manner: First i fill the cores from left to right and then the second thread inside each core. The core numbers (validated using
lstopo) are: (0,4), (1,5), (2,6), (3,7). Thus no special mapping is really needed.
I have tested the centralized sense reversing barrier with the following configuration options:
	(A) Relaxed Memory Model with Hardware Prefetching Enablded. Results are in file "CentralizedSenseReversingBarrierRelaxedWithHardwarePrefetching"
	(B) Relaxed Memory Model with Hardware Prefetching Disabled. Results are in file "CentralizedSenseReversingBarrierRelaxedWithoutHardwarePrefetching"

My first observation is that the Sequentially-Consistent Version outperforms both relaxed versions i tried.

Let's investigate the issue. I use the command "objdump -S --disassemble intel_i7_benchmark_suite" to look at the assembly code. I search for the await() function. My goal in 
the beginning is to test if the code generated by the gcc compiler somehow affects the results. I expect that the code for the relaxed version is "shorter".
Let's see what code is produced: 
	- count.fetch_add(seq_cst) : lock xadd
	- count.fetch_add(acq_rel) : lock xadd 
	They are the same probably because they are RMW operations

	- count.store(seq_cst) : mfence
	- count.store(relaxed)

After a while i discovered that having -O0 makes gcc treat all atomics the same! I tried again with -O3 and lets see... Indeed the relaxed versions are better!! 
The relaxed 2 version is better as epxected because i avoid 2 load operations each time. However the first relaxed version even with those 2 load operations still outperforms
the sequential-consistent version. Thus because i expect that this relaxed version will outperform the relaxed 2 version in other systems (like PowerPC) i will use the
first relaxed version.
Why? The reason should be that the seq-cst versions have an additional associated cost for fence instructions. Let's try use "perf" to see if that's an issue.
 
(remember the purpose of this study is to show the cost of memory barriers)

Using perf: 
perf record ./intel...
pref report

kai pao sto annotate kai blepo pragmati oti sto store exei ena mfence eno sto relaxed version den exei mfence apo kato. Bebaia i diafora den einai kai megali.


|-----------------------------------------------|
|Results for Static Tree Barrier		|
|-----------------------------------------------|
My goals here is to show again the cost of memory fences. Also, the second goal that i have is to show the effect of locality which in turn is affected by the shape
of the static tree. However for this case i do not test the effect of the shape of the static tree (use fan-in=fan-out=2) and also test against the locality.

First 
